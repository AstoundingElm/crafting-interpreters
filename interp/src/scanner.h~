#pragma once
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "defines.h"

struct Scanner{

  const b8 * start;
  const b8 * current;
  i32 line;

};

 enum Token_Type{
 // Single-character tokens
 TOKEN_LEFT_PAREN, TOKEN_RIGHT_PAREN,
 TOKEN_LEFT_BRACE, TOKEN_RIGHT_BRACE,
 TOKEN_COMMA, TOKEN_DOT, TOKEN_MINUS, TOKEN_PLUS,
 TOKEN_SEMICOLON, TOKEN_SLASH, TOKEN_STAR,
 // One or two character tokens.
 TOKEN_BANG, TOKEN_BANG_EQUAL,
 TOKEN_EQUAL, TOKEN_EQUAL_EQUAL,
 TOKEN_GREATER, TOKEN_GREATER_EQUAL,
 TOKEN_LESS, TOKEN_LESS_EQUAL,
 // Literals.
 TOKEN_IDENTIFIER, TOKEN_STRING, TOKEN_NUMBER,
 // Keywords.
 TOKEN_AND, TOKEN_CLASS, TOKEN_ELSE, TOKEN_FALSE,
 TOKEN_FOR, TOKEN_FUN, TOKEN_IF, TOKEN_NIL, TOKEN_OR,
 TOKEN_PRINT, TOKEN_RETURN, TOKEN_SUPER, TOKEN_THIS,
 TOKEN_TRUE, TOKEN_VAR, TOKEN_WHILE,
 TOKEN_ERROR,
 TOKEN_EOF
 };

struct Token{

  Token_Type type;
  const b8 * start;
  i32 length;
  i32 line;
};

static Scanner scanner;

PINLINE bool is_at_end(){

  return *scanner.current == '\0';
};

PINLINE Token makeToken(Token_Type type){

  Token token;
  token.type = type;
  token.start = scanner.start;
  token.length = (i32)(scanner.current - scanner.start);
  token.line = scanner.line;
  return token;
  
};

PINLINE Token error_token(const b8 * message){

  Token token;
  token.type = TOKEN_ERROR;
  token.start = message;
  token.length = (i32)strlen(message);
  token.line - scanner.line;

  return token;

};

PINLINE b8 advance(){

  scanner.current++;
  return scanner.current[-1];
};

PINLINE bool match(b8 expected){

  if(is_at_end()) return false;
  if(*scanner.current != expected) return false;

  scanner.current++;
  return true;
};

PINLINE b8 peek(){

  retun *scanner.current;
};

PINLINE void skip_whitespace(){

  for(;;){

    char c = peek();

    switch(c){

    case ' ':
    case '\r':
    case '\t':
      advance();
      break;

    case: '\n':
      scanner.line++;
      advance();
    default: return;
    }
    
    ]
  
};

Token scan_token(){

  skip_whitespace();

  scanner.start = scanner.current;
  if(is_at_end()) return make_token(TOKEN_EOF);

  char c = advance();

  switch (c){

  case '(': return makeToken(TOKEN_LEFT_PAREN);
    case ')': return makeToken(TOKEN_RIGHT_PAREN);
 case '{': return makeToken(TOKEN_LEFT_BRACE);
 case '}': return makeToken(TOKEN_RIGHT_BRACE);
 case ';': return makeToken(TOKEN_SEMICOLON);
 case ',': return makeToken(TOKEN_COMMA);
 case '.': return makeToken(TOKEN_DOT);
 case '-': return makeToken(TOKEN_MINUS);
 case '+': return makeToken(TOKEN_PLUS);
 case '/': return makeToken(TOKEN_SLASH);
 case '*': return makeToken(TOKEN_STAR);
   case '*': return makeToken(TOKEN_STAR);
 case '!':
 return makeToken(
 match('=') ? TOKEN_BANG_EQUAL : TOKEN_BANG);
 case '=':
 return makeToken(
 match('=') ? TOKEN_EQUAL_EQUAL : TOKEN_EQUAL);
 case '<':
 return makeToken(
 match('=') ? TOKEN_LESS_EQUAL : TOKEN_LESS);
 case '>':
 return makeToken(
 match('=') ? TOKEN_GREATER_EQUAL : TOKEN_GREATER);

  };
  return error_token("unexpected character");

};



PINLINE void init_scanner(const b8 * source){

  scanner.start = source;
  scanner.current = source;
  scanner.line = 1;
};
